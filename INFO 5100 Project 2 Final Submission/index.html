<!DOCTYPE html>

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word cloud</title>
    <!--- D3 IMPORT HERE --->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-cloud/1.2.5/d3.layout.cloud.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/seedrandom/2.4.3/seedrandom.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <!--- D3 IMPORT HERE --->
    <style>

        h1 {
            font-weight: 500;
            font-size: 30pt;
            padding: 20;
            margin: 20;
            text-align: center;
        }

        h3 {
            position: relative;
            left: 300px;
            top: 10px;

            font-family: Georgia, serif;
            font-size: 20px;

            font-weight: 600;
            text-align: left;
        }

        h4 {
            font-weight: 500;
            font-size: 11pt;
            padding: 5;
            margin: 0;
            text-align: center;
        }

        div#description {
          position: relative;
          left: 300px;
          top: 10px;

          width: 850px;

        }

        p#description, #question {
          font-family: Georgia, serif;
          font-size: 16px;
        }

        .state {
            fill: lightgrey;
        }

        .graticule {
            fill: none;
            stroke: grey;
            stroke-width: 1px;
            opacity: 0.4;
        }

        .outline {
            fill: none;
            stroke: black;
            stroke-width: 1px;
        }

        .gridlines .domain {
          display: none;
        }

        .gridlines line {
          stroke: lightgrey;
        }

        g.mouseover rect {
          stroke: #222;
          stroke-width: 1px;
        }
        g.mouseover text {
          font-family: Georgia, serif;
          font-size: 13px;
        }
        g.mouseover text:first-child {
          font-weight: bold;
          font-size: 15px;
        }

        label {
          font-family: Georgia, serif;
          font-size: 15px;
          font-weight: bold;
          font-style: italic;
        }


    </style>
</head>

<body>

  <body>
      <!-- Title & Overview for Project -->
      <h1> Twitter Word Usage Habits </h1>
      <div id="description">
        <p id="description">
          By 2021, it has <b>211 million</b> active users. On average, there are about <b>500 million</b> tweets sent every day.
          Information exchange and spread happen quickly on this platform. However, those tweets tend to vary significantly
          across users in aspects of contents and word choices.<br>
        </p>
        <p id="question">
          <b><i>What are similarities and differences in word usages while tweeting among Twitter users
          from different professional backgrounds?</i></b>
        </p>
        <p id="description">
          The visualization will demonstrate 30 Twitter users' word-usage habits, who come freom 6 professional groups:
          <i>Sports Analysts</i>, <i>NBA Players</i>, <i>Actors/Actresses</i>, <i>Musicians</i>, <i>Entrepreneurs</i>, and <i>Cornell Faculties</i>.
        </p>
      </div>

      <!-- Title & Description for Plot 1-->
      <div id="p1_title">
        <h3> Graph 1: Most Frequently Used Words by User Groups</h3>
        <div id="description">
          <p id="description">
            In this visualization, you will explore the most frequently used top words by the 30 Twitter users. You can select a
            usergroup to view top words shared by the 5 individuals in a specific professional group.
          </p>
        </div>
     </div>
     <!-- Plot 1: Word Cloud -->
      <div id="p1" style="text-align: center;">
      <p id="p1">
        <div id="pulldown-bar" >
        	<label for="usergroup-select-1" id="usergroup-1">Usergroup: </label>
            <select id="sort-select" style="width:200px; margin-left: 5px; margin-top: 15px;" >
                <option value="full" selected>Show All Users</option>
                <option value="sport">Show Sports Analyst</option>
                <option value="actor">Show Actor or Actress</option>
                <option value="nba">Show NBA Player</option>
                <option value="musician">Show Musician</option>
                <option value="entrepreneur">Show Entrepreneur</option>
                <option value="cornell">Show Cornell Faculty</option>
                </select>
        </div>
        <svg id="word-cloud" height="500" width="900" style="margin:20px;" /> </svg>

        <!-- Coding for Plot 1 Starts Here -->
        <script>
            let svg1 = d3.select("svg#word-cloud");
            let width1 = svg1.attr("width");
            let height1 = svg1.attr("height");

            let requestData = async function () {
                let word_freq;

                let full_freq = await d3.json("./datasets/word-freq-select-full.json");
                let actor_freq = await d3.json("./datasets/word-freq-select-actor.json")
                let cornell_freq = await d3.json("./datasets/word-freq-select-cornell.json")
                let entrepreneur_freq = await d3.json("./datasets/word-freq-select-entrepreneur.json")
                let musician_freq = await d3.json("./datasets/word-freq-select-musician.json")
                let nba_freq = await d3.json("./datasets/word-freq-select-nba.json")
                let sport_freq = await d3.json("./datasets/word-freq-select-sport.json")

                drawByData(full_freq)

                d3.select("#sort-select").on("change", function () {
                    svg1.selectAll("*").remove();

                    var option = d3.select(this).property("value")
                    console.log(option);

                    if (option === "actor") {
                        word_freq = actor_freq
                    }
                    else if (option === "cornell") {
                        word_freq = cornell_freq
                    }
                    else if (option === "entrepreneur") {
                        word_freq = entrepreneur_freq
                    }
                    else if (option === "musician") {
                        word_freq = musician_freq
                    }
                    else if (option === "nba") {
                        word_freq = nba_freq
                    }
                    else if (option === "sport") {
                        word_freq = sport_freq
                    }
                    else {
                        word_freq = full_freq
                    }

                    drawByData(word_freq)
                })

            }
            // Call requestData() function
            requestData();

            function drawByData(word_freq) {
                // Create a color pallete for Plot 1
                let fill = d3.scaleOrdinal(["#4e79a7","#f28e2c","#e15759","#76b7b2","#59a14f","#edc949","#af7aa1","#ff9da7","#9c755f","#bab0ab"]);

                let data1 = word_freq;
                const freqExtent = d3.extent(data1, d => d['value']);
                console.log(freqExtent);

                // Create a scale to determine font size
                const wordScale = d3.scaleLog()
                    .domain(freqExtent)
                    .range([20, 150])

                var layout = d3.layout.cloud()
                    .size([width1, height1])
                    .words(data1)
                    .font("Impact")
                    .fontSize(d => wordScale(d['value']))
                    .padding(3)
                    .rotate(function () { return 0; })
                    .on("end", draw);

                layout.start();

                function draw(words) {
                  d3.select("svg#word-cloud")
                      .append("g")
                      .attr("id", "wordInCloud")
                      .attr("transform", "translate(" + layout.size()[0] / 2 + "," + layout.size()[1] / 2 + ")")
                      .selectAll("text")
                      .data(words)
                      .join("text")
                      .text((d) => d.text)
                      .style("font-size", (d) => d.size + "px")
                      .style("font-family", (d) => d.font)
                      .transition().duration(600)
                      .style("fill", (d, i) => fill(i))
                      .attr("text-anchor", "middle")
                      .attr("transform", (d) => "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")");
                }

            }
        </script>
    </p>
    </div>

    <!-- Title & Description for Plot 2 -->
    <div id="p2_title">
      <h3> Graph 2: Word Usage Frequency in Percentage by Groups & Users </h3>
      <div id="description">
        <p id="description">
          In this bar chart, you will see the percentage of tweets containing the top words from the 30 Twitter users. You can make
          a selection of the usergroup to explore the word usage habits in this group. You can also choose an interesting top word
          to explore its frequency distribution among users. To view more details about a user, you can mouse on a bar. 
        </p>
      </div>
   </div>
   <!-- Plot 2: Bar Chart -->
    <div id="p2" style="text-align: center;">
    <p id="p2">
        <!-- Create dropdown menus -->
        <div id = "dropdown">
          <label for="usergroup-select" id="usergroup">Usergroup: </label>
          <select id="usergroup-select" style="width:200px; margin-right: 50px; margin-left: 5px; margin-top: 15px;">
            <option value="AllUsers" selected>Show All Users</option>
            <option value="Sport Analyst">Show Sports Analyst</option>
            <option value="Actor or Actress">Show Actor or Actress</option>
            <option value="NBA Player">Show NBA Player</option>
            <option value="Musician">Show Musician</option>
            <option value="Entrepreneur">Show Entrepreneur</option>
            <option value="Cornell Faculty">Show Cornell Faculty</option>
          </select>

          <label for="keyword-select" id="word">Top Word: </label>
          <select id="keyword-select" style="width:200px; margin-left: 5px; margin-top: 15px;">
          </select>
        </div>
        <!-- Create SVG -->
        <div id="barchart_svg">
          <svg id="bar-chart" height="600" width="800" style="margin-top: 1px; margin-bottom: 25px;">
          </svg>
        </div>

      <!-- Coding part for Plot 2 starts here -->
      <script id="p2">

          // Prepare & Plot the SVG
          const svg = d3.select("svg#bar-chart");
          const width = svg.attr("width");
          const height = svg.attr("height");
          const margin = {top: 50, right: 10, bottom: 50, left: 50};
          const chartWidth = width - margin.left - margin.right;
          const chartHeight = height - margin.top - margin.bottom;

          let annotations = svg.append("g").attr("id","annotations");
          let chartArea = svg.append("g").attr("id","points")
                          .attr("transform",`translate(${margin.left},${margin.top})`);

          // Create a small mouseover area
          const mouseover = svg.append("g").attr("class","mouseover")
                               .attr("transform",`translate(${margin.left+15},${margin.top+15})`);

         // Create a function to figure out the length of a string
          function stringLen(str) {
             const dummytext = mouseover.append("text").attr("class","legendtext").attr("visibility","hidden");
             dummytext.text(str)
             let len = dummytext.node().getComputedTextLength()
             dummytext.remove()
             return len;
          }

          const frame = mouseover.append("rect").attr("class","frame")
                                 // we style this in <head>
                                 .attr("x", 500).attr("y", 0)
                                 .attr("rx", 5).attr("ry", 5)  // rx and ry round corners
                                 .attr("height", 80);  // set width later
          const textbox = mouseover.append("g").attr("transform","translate(10,10)");
          const format = d3.format('.2s');

          // Create a function to updates the mouseover contents given a piece of data
          function updateMouseover(d) {

            textbox.html('');

            let twitter = `@${d['user']}`;
            let name = `${d['name']}`;
            let follower = `Follower: ${format(d['follower'])}`;

            let maxWidth = Math.max( stringLen(twitter), stringLen(name), stringLen(follower) )
            frame.attr("width", maxWidth+75);

            if ( d3.select("#usergroup-select").node().value === "AllUsers"){
              textbox.append("text").text(name)
                     .attr("x", 500).attr("y", 10);
              textbox.append("text").text(twitter)
                     .attr("x", 500).attr("y", 30);
              textbox.append("text").text(follower)
                     .attr("x", 500).attr("y", 50);

              let fill = colorScale(d['usergroup']);
              frame.attr('fill', fill)
              		.attr('x', 500)
                  .attr('opacity', 0.5);
            }
            else{
              textbox.append("text").text(name)
                     .attr("x", 5).attr("y", 10);
              textbox.append("text").text(twitter)
                     .attr("x", 5).attr("y", 30);
              textbox.append("text").text(follower)
                     .attr("x", 5).attr("y", 50);

              frame.attr('x', 5)
                  .attr('fill', 'white')
            }

          }

          // Create y-axis and y-gridelines
          // y-axis: represent the percentage of post containing a specific word
          // y-axis is going to change based on selected usergroup and word
          let leftAxis = d3.axisLeft().tickFormat(d3.format('.1%'));
          let leftAxisG = annotations.append("g")
                                    .attr("class", "y axis")
                                    .attr("transform",`translate(${margin.left-10},${margin.top})`);

          let leftGridlines = d3.axisLeft()
                                .tickSize(-chartWidth-10)
                                .tickFormat("");
          let leftGridlinesG = annotations.append("g")
                                    .attr("class", "y gridlines")
                                    .attr("transform",`translate(${margin.left-10},${margin.top})`);

          // Create colorScale for six usergroups
          const usergroup_categories = ['Sport Analyst', 'Actor or Actress', 'NBA Player', 'Musician', 'Entrepreneur', 'Cornell Faculty'];
          const colorpalate = ['#4e79a7', '#AF7AA1', '#E15759', '#FF9DA7', '#59A14F', '#F28E2C'];
          const colorScale = d3.scaleOrdinal()
                              .domain(usergroup_categories)
                              .range(colorpalate);

          // Create x-axis & x-gridlines
          // x-axis: represent different usergroups / different users
          // The x-axis is going to change because selected usergroup from dropdown menu changes
          let bottomAxis = d3.axisBottom();
          let bottomAxisG = annotations.append("g")
                                   .attr("class", "x axis")
                                   .attr("transform",`translate(${margin.left},${chartHeight+margin.top+10})`);

          // Create a function to update Bar Chart
          async function updateBarsAnimated( usergroup, word_chosen ) {

            // load in categorized_users.json data file
            const categorized_users = await d3.json("./datasets/user_under_categories.json", d3.autoType);
            console.log("Categorized Users: ", categorized_users);

            // create user account and name pairs
            let user_name_pair = new Array();
            categorized_users.forEach( d => {
              d.users.forEach( (u, i) => {
                user_name_pair[u] = d.names[i];
              })
            });

            // load in processed-date-top-words.json data file
            let data = await d3.json("./datasets/top-words_percent.json", d3.autoType);
            console.log("Data: ", data);

            // load in user-followers.csv file
            let followers = await d3.csv("./datasets/user-followers.csv", d3.autoType);
            console.log("Followers: ", followers);

            // remove all pre-existing bars
            let bars = d3.selectAll('rect.bar');
            bars.remove();

            //
            // Check whether usergroup === "AllUsers"
            //
            if( usergroup === "AllUsers") {
              const groups = d3.map(categorized_users, d => d.usergroup);
              const groupScale = d3.scaleBand()
                                  .domain(groups)
                                  .range([0, chartWidth])
                                  .padding(0.2);

              const userScale = d3.scaleBand()
                                  .domain([0, 1, 2, 3, 4])
                                  .range([0, groupScale.bandwidth()])
                                  .padding(0.15);

              bottomAxis.scale(groupScale);
              bottomAxisG.transition().call(bottomAxis);

              //
              // process data array to categorize user data
              //
              let processed_data = new Array();
              usergroup_categories.forEach( u => {
                // STEP 1: get all user accounts falling into the usergroup
                const group = d3.filter(categorized_users, d => (d.usergroup === u));
                let users = group[0].users;

                // StTEP 2: create processed array for later data join
                for ( const [key, value] of Object.entries(data) ){
                  let new_dict = {}
                  if (users.indexOf(key) >= 0) {
                    new_dict['user'] = key;
                    new_dict['name'] = user_name_pair[key];
                    new_dict['word_frequency'] = value;
                    new_dict['usergroup'] = u;
                    new_dict['index'] = users.indexOf(key);

                    // find the number of followers for the user
                    followers.forEach( (d,i) => {
                      if (d.Username === key) {
                        new_dict['follower'] = d.Follower_Count;
                      }
                    })

                    processed_data.push(new_dict);
                  }
                }

              })
              console.log('Processed Data: ', processed_data);


              // Create percenExtent for y-axis
              let word_frequency_count = [];
              processed_data.forEach( d => {
                word_frequency_count.push(d.word_frequency[word_chosen]);
              })

              let percentExtent = d3.extent(word_frequency_count);
              let percentScale = d3.scaleLinear().domain([0, percentExtent[1]])
                                    .range([chartHeight, 0]);
              // Draw y-axis & y-gridlines
              leftAxis.scale(percentScale);
              leftAxisG.transition().call(leftAxis);

              leftGridlines.scale(percentScale);
              leftGridlinesG.transition().call(leftGridlines);


              // use data join of processed_data to plot bar chart
              let bars = chartArea.selectAll('rect.bar').data(processed_data)
                                  .join( enter => enter.append('rect')
                                                       .attr('class','bar')
                                                       .attr('id', d => d.user)
                                                       .attr('fill', d => colorScale(d.usergroup))
                                                       .attr('x', d => groupScale(d.usergroup) + userScale(d.index))
                                                       .attr('y', d => percentScale(d.word_frequency[word_chosen]))
                                                       .attr('height', d => percentScale(0) - percentScale(d.word_frequency[word_chosen]))
                                                       .attr('width', userScale.bandwidth())
                                                       .attr('opacity', 0)
                                                       .call( enter => enter.transition().attr('opacity',0.9) ),
                                        update => update.call( update => update.transition()
                                                                                .attr('fill', d => colorScale(d.usergroup))
                                                                                .attr('x', d => groupScale(d.usergroup) + userScale(d.index))
                                                                                .attr('y', d => percentScale(d.word_frequency[word_chosen]))
                                                                                .attr('height', d => percentScale(0) - percentScale(d.word_frequency[word_chosen]))
                                                                                .attr('width', userScale.bandwidth()) ),
                                        exit => exit.call( exit => exit.transition().attr('opacity',0).remove() )

                                      );

              // Add some mouseover events
              bars.on('mouseover', function(d) {
                mouseover.attr("visibility","");
                updateMouseover( d3.select(this).datum() )
              })

              bars.on('mouseout', function(){
                mouseover.attr("visibility","hidden");
              })

            }

            //
            // Show Bar Chart for a Single User Group
            //
            else {
              // get the data for specific user group
              const group = d3.filter(categorized_users, d => (d.usergroup === usergroup));
              // get all users' Twitter accounts
              let users = group[0].users;
              // get all users' real names
              let names = group[0].names;

              const userScale = d3.scaleBand()
                                  .domain(names)
                                  .range([0, chartWidth])
                                  .padding(0.25);

              bottomAxis.scale(userScale);
              bottomAxisG.transition().call(bottomAxis);

              let users_data = new Array();

              // get the corresponding user data from data array
              for ( const [key, value] of Object.entries(data) ){
                let new_dict = {}
                if (users.indexOf(key) >= 0) {
                  new_dict['user'] = key;
                  new_dict['name'] = user_name_pair[key];
                  new_dict['word_frequency'] = value;
                  new_dict['index'] = users.indexOf(key);

                  // find the number of followers for the user
                  followers.forEach( (d,i) => {
                    if (d.Username === key) {
                      new_dict['follower'] = d.Follower_Count;
                    }
                  })

                  users_data.push(new_dict);
                }
              }
              console.log("User Data: ", users_data);

              // Create percenExtent for y-axis
              let word_frequency_count = [];
              users_data.forEach( d => {
                word_frequency_count.push(d.word_frequency[word_chosen]);
              })

              let percentExtent = d3.extent(word_frequency_count);
              let percentScale = d3.scaleLinear().domain([0, percentExtent[1]])
                                    .range([chartHeight, 0]);
              // Draw y-axis & y-gridlines
              leftAxis.scale(percentScale);
              leftAxisG.transition().call(leftAxis);

              leftGridlines.scale(percentScale);
              leftGridlinesG.transition().call(leftGridlines);

              // Use data join to append bars
              let bars = chartArea.selectAll('rect.bar').data(users_data)
                                  .join(
                                    enter => enter.append('rect')
                                                         .attr('class','bar')
                                                         .attr('id', d => d.user)
                                                         .attr('fill', colorScale(usergroup))
                                                         .attr('x', d => userScale(user_name_pair[d.user]))
                                                         .attr('y', d => percentScale(d.word_frequency[word_chosen]))
                                                         .attr('height', d => percentScale(0) - percentScale(d.word_frequency[word_chosen]))
                                                         .attr('width', userScale.bandwidth())
                                                         .attr('opacity', 0)
                                                         .call( enter => enter.transition().attr('opacity',0.9) ),
                                    update => update.call( update => update.transition()
                                                                            .attr('fill', colorScale(usergroup))
                                                                            .attr('x', d => userScale(user_name_pair[d.user]))
                                                                            .attr('y', d => percentScale(d.word_frequency[word_chosen]))
                                                                            .attr('height', d => percentScale(0) - percentScale(d.word_frequency[word_chosen]))
                                                                            .attr('width', userScale.bandwidth()) ),
                                    exit => exit.call( exit => exit.transition().attr('opacity',0).remove() )
                                  );

              // add some mouseover events
              // Add some mouseover events
              bars.on('mouseover', function(d) {
                mouseover.attr("visibility","");
                updateMouseover( d3.select(this).datum() )
              })

              bars.on('mouseout', function(){
                mouseover.attr("visibility","hidden");
              })

            }

          }

          // Default drop-down menus for all user groups
          var usergroup_selected = d3.select("#usergroup-select").node().value;
          // Build the corresponding keyword selectors
          buildKeywordSelet( usergroup_selected );
          // initialize the bar chart
          updateBarsAnimated( "AllUsers", "game" );

          d3.select("#keyword-select").on("change", function(){
            keyword_selected = d3.select(this).property("value");
            // console.log("User Group Chosen: ", usergroup_selected);
            // console.log("Top Word Chosen: ", keyword_selected);
            updateBarsAnimated( usergroup_selected, keyword_selected );

          })

          // Update the drop-down menus
          // Get "usergroup-select" value property
          // then build "keyword-select" options
          d3.select("#usergroup-select").on("change", function(){
            // get the "usergroup-select" option value
            usergroup_selected = d3.select(this).property("value");
            console.log("Usergroup: ", usergroup_selected);
            // call buildKeywordSelet function to build "keyword-select" options
            buildKeywordSelet( usergroup_selected );
            // get the "keyword-select" option value
            d3.select("#keyword-select").on("change", function(){
              keyword_selected = d3.select(this).property("value");
              // console.log("User Group Chosen: ", usergroup_selected);
              // console.log("Top Word Chosen: ", keyword_selected);
              updateBarsAnimated( usergroup_selected, keyword_selected );

            })

            let initial_word = {"AllUsers": "game", "Sport Analyst": "lebron", "Actor or Actress": "love",
            "NBA Player": "lol", "Musician": "steveaoki", "Entrepreneur": "uber", "Cornell Faculty": "data"};

            updateBarsAnimated( usergroup_selected, initial_word[usergroup_selected] );
          });

          //
          // Create a function to build "keyword-select" options
          //
          async function buildKeywordSelet( usergroup ) {

            // Call requestTopWords( usergroup ) to get option list
            let option_list = await requestTopWords( usergroup );
            // Append the option
            let keyword_select = d3.select("select#keyword-select");
            let word_options = d3.selectAll("option#words");

            // Remove all pre-existing options
            word_options.remove();

            // Create new options for the "keyword-select"
            option_list.forEach( (d,i) => {
                keyword_select.append("option")
                            .attr("id", "words")
                            .attr("value", d.text)
                            .text(d.format)
            })

          } // END OF buildKeywordSelet FUNCTION

          //
          // Create a function to load the top words
          //
          async function requestTopWords( usergroup ) {

            let top_words;

            // Get the top 10 words shared by 6 user groups
            if (usergroup === "AllUsers") {
              // load top-words-AllUsers dataset
              top_words = await d3.json("./datasets/top-words-AllUsers.json", d3.autoType);
            }
            // Get the top 5 words shared by an individual user group
            else {
              // load the corresponding datasets
              top_words = await d3.json("./datasets/top-words-"+usergroup+".json", d3.autoType);
            }

            return top_words;

          }// END OF requestWord_All_Groups FUNCTION

        </script>

    </p>
    </div>

    <!-- Title & Description for Plot 3 -->
    <div id="p3_title">
      <h3> Graph 3: States Mentioned by Sports Analysts</h3>
      <div id="description">
        <p id="description">
          Sports Analysts tend to mention lots of state names in their tweets due to their professional habits. <i>What
          are most frequently mentioned states in their posts? Why are those states mentioned more than others?</i>
        </p>
        <p id="description">
          You can select a Sports Analyst to explore the frequency distribution of states mentioned in his tweets.
        </p>
      </div>
    </div>
    <!-- Plot 3: Choropleth Map -->
    <div id="p3" style="text-align: center;">
      <p id="p3">
          <!-- Create dropdown menus -->
          <div id="sport-analyst-dropdown">
              <label for="sport-analyst" id="users">
              	Choose a Sports Analyst:
              </label>
              <select id="sport-analysts" style="width:200px; margin-left: 5px; margin-top: 15px">
                <option value="total">All Sports Analysts</option>
                <option value="RealSkipBayless">Skip Bayless</option>
                <option value="ShannonSharpe">Shannon Sharpe</option>
                <option value="PatMcAfeeShow">Pat McAfee</option>
                <option value="stephenasmith">Steven A. Smith</option>
                <option value="maxkellerman">Max Kellerman</option>
              </select>
          </div>
      <!-- Create SVG -->
      <svg id="userInfo" height="120" width="700" style="background: #fff; margin-top:2px"></svg>
      <svg id="choropleth" height="600" width="900" style="background: #F1F9FF; margin-top:2px"></svg>
      <svg id="colorLegend" height="100" width="700" style="background: #fff; margin-top:2px"></svg>

      <!-- Coding part for Plot 3 starts here -->
      <script>
          const svg3 = d3.select('#choropleth');

          // Get the attributes of the svg
          const svgWidth3 = svg3.attr('width');
          const svgHeight3 = svg3.attr('height');

          // Create choropleth map attributes
          const margin3 = { left: 10, right: 10, top: 10, bottom: 10 };
          const plotWidth3 = svgWidth3 - margin3.left - margin3.right;
          const plotHeight3 = svgHeight3 - margin3.top - margin3.bottom;

          const plot = svg3.append('g').attr('transform', `translate(${margin3.left}, ${margin3.right})`);

          let tweetStateData;
          let freq = {};

          // Create the popup
          let popupWidth = 120;
          let popupHeight = 50;

          let momesh = plot.append('path')
                              .attr('class', 'mouseover outline')
                              .attr('d', '')

          let popup = plot.append('g')
                          .attr('class', 'popup')
                          .attr('visiblity', 'hidden')

          popup.append('rect')
                  .attr('fill', 'black')
                  .attr('opacity', 0.8)
                  .attr('x', -popupWidth / 2)
                  .attr('y', 0)
                  .attr('width', popupWidth)
                  .attr('height', popupHeight)
          popup.style('visibility','hidden');

          let stateText = popup.append('text')
                                  .attr("fill", "white")
                                  .attr("text-anchor","middle")
                                  .attr("alignment-baseline","hanging")
                                  .attr("font-size", 15)
                                  .attr("x", 0)
                                  .attr("y", 10);

          let freqText = popup.append('text')
                              .attr("fill", "white")
                              .attr("text-anchor","middle")
                              .attr("alignment-baseline","hanging")
                              .attr("font-size", 15)
                              .attr("x", 0)
                              .attr("y", 30);


          let path, data;

          const makeChoropleth = async function() {

              // Load twitter data for choropleth map
              tweetStateData = await d3.json('./datasets/twitterStateMentions.json', d3.autotype);

              // Modeled after topojson lecture code by Prof Rz.
              data = await d3.json('./datasets/us-smaller.json');

              let states = topojson.feature(data, data.objects.states);
              let statesMesh = topojson.mesh(data, data.objects.states);
              let projection2d = d3.geoAlbersUsa().fitSize([plotWidth3, plotHeight3], states);
              path = d3.geoPath().projection(projection2d);
              let graticule = d3.geoGraticule10();

              plot.append('path')
                  .attr('class', 'graticule')
                  .attr('d', path(graticule))

              plot.selectAll('path.state')
                  .data(states.features)
                  .join('path')
                  .attr('class', 'state')
                  .attr('d', path)

              plot.append('path')
                  .datum(statesMesh)
                  .attr('class', 'outline')
                  .attr('d', path)

              let dropdown = d3.select('select#sport-analysts')
                  .on('change', updateChoropleth)

              let emptyData = await d3.csv('./datasets/empty-states.csv', d3.autotype);
              stateMap = {}
              emptyData.forEach( obj => {
                  stateMap[obj.state_code] = obj.state_name;
              })

              d3.selectAll('.state').on('mouseenter', function() {
                  return mouseEnterState(this, stateMap)
              });
              d3.selectAll('.state').on('mouseout', mouseExitState);

              updateChoropleth(); // update once with the cumulative data
          }

          function mouseEnterState(obj, stateMap) {

              popup.style('visibility', 'visible');
              popup.raise();
              let currentState = d3.select(obj);
              let currentStateId = currentState.datum().id;

              stateText.text(stateMap[currentStateId]);
              freqText.text(d3.format('.2f')(freq[currentStateId]*100) + '%')

              let currentStateBounds = path.bounds(currentState.datum());

              // Ceter it above the current state
              let xPos = (currentStateBounds[0][0] + currentStateBounds[1][0]) / 2;
              let yPos = currentStateBounds[0][1] - popupHeight + 10;

              popup.attr('transform', `translate(${xPos}, ${yPos})`);

              let mo = topojson.mesh(data, data.objects.states, function(a, b) { return a.id === currentStateId || b.id === currentStateId; });
              momesh.datum(mo).attr("d", path);

          }

          function mouseExitState() {

              popup.style('visibility','hidden');
              momesh.attr("d", "");

         }

         // Create a function to update Choropleth Map
          const updateChoropleth = async function() {
              console.log("UPDATING");
              console.log(tweetStateData);

              let select = d3.select('select#sport-analysts');
              let username = select.node().value;

              let total = Number(tweetStateData['Num_Tweets'][username]);
              let emptyStateData = await d3.csv('./datasets/empty-states.csv', d3.autotype);

              // Create dictionaries to store the plot data - modeled after Prof Rz's lecture
              counts = {};
              names = {};
              freq = {};

              let count;
              // Update emptyStateData based on the selected user
              emptyStateData.forEach( (obj) => {
                  count = tweetStateData[obj.state_name][username];
                  obj.total = count;
                  counts[obj.state_code] = count;
                  names[obj.state_code] = obj.state_name;
                  freq[obj.state_code] = count * 100 / total;
              })

              console.log('COUNTS');
              console.log(counts);

              //
              // Styling
              //
              let colorScale = d3.scaleQuantile()
                                  .domain(Object.values(counts))
                                  .range(["#B3D0ED","#5A8BBC","#1B4875","#082F56"]);

              // Color the choropleth map
              plot.selectAll('path.state')
                  .style('fill', d => colorScale(counts[d.id]))
                  .attr("opacity", 0.8)

              // Draw legend
              const map_legend = d3.select("svg#colorLegend")

              drawLegend(d3.select("#colorLegend"), colorScale);

              // Add Info Box
              const Info = d3.select('svg#userInfo');
              Info.append("rect")
                  .attr("x", 0)
                  .attr("height", 300)
                  .attr("y", 0)
                  .attr("width", 900)
                  .attr("fill", "white")


             let Info_detail_max5, Info_detail_other1, Info_detail_other2, Info_detail_other3;
              if (username === "total") {
                  Info_detail_max5 = "Top 5 States: Maine / Indiana / Washington / Texas / Ohio"
                  Info_detail_other1 = " "
                  Info_detail_other2 = " "
              }
              else if (username === "RealSkipBayless") {
                  Info_detail_max5 = "Top 5 States: Texas / Oklahoma / Washington / Ohio / Arizona"
                  Info_detail_other1 = "1)　Born in Oklahoma City, Oklahoma"
                  Info_detail_other2 = "2)　Fan of the Dallas Cowboys (Texas) NFL team and Oklahoma Sooners College Football Team"
              }
              else if (username === "ShannonSharpe") {
                  Info_detail_max5 = "Top 5 States: Maine / Indiana / Washington / Texas / Ohio"
                  Info_detail_other1 = "1)　Attended Savannah State University (Georgia)"
                  Info_detail_other2 = "2)　Played in the NFL for the Denver Broncos (Colorado) and Baltimore Ravens (Maryland)"
              }
              else if (username === "PatMcAfeeShow") {
                  Info_detail_max5 = "Top 5 States: Indiana / Ohio / Washington / Virginia / Texas"
                  Info_detail_other1 = "1)　Born in Pennsylvania"
                  Info_detail_other2 = "2)　Played in the NFL for the Indianapolis Colts (Indiana)"
              }
              else if (username === "maxkellerman") {
                  Info_detail_max5 = "Top 5 States: Kentucky / New York / Alabama / Washington / Ohio"
                  Info_detail_other1 = "1)　Hosts ESPN shows in New York"
                  Info_detail_other2 = "2)　Avid boxing fan"
              }
              else if (username === "stephenasmith") {
                  Info_detail_max5 = "Top 5 States: New York / Alabama / Michigan / Kentucky / Ohio"
                  Info_detail_other1 = "1)　Hosts ESPN shows in New York"
                  Info_detail_other2 = "2)　Infamous Dallas Cowboys 'hater' "
              }

              let InfoText = Info.append('text')
                              .attr("fill", "black")
                              .attr("text-anchor","left")
                              .attr("alignment-baseline","hanging")
                              .attr("font-size", 14)
                              .attr("font-weight", 800)
                              .attr("x", 20)
                              .attr("y", 10);

              if (username === "total") {
                InfoText.text("All Sports Analysts");
              }

              else {
                InfoText.attr("font-style", "italic");
                InfoText.text("@"+username);
              }

              let InfoText_max = Info.append('text')
                              .attr("fill", "black")
                              .attr("text-anchor","left")
                              .attr("alignment-baseline","hanging")
                              .attr("font-size", 13)
                              .attr("font-weight", 350)
                              .attr("x", 20)
                              .attr("y", 40)
              InfoText_max.text(Info_detail_max5)

              let InfoText3 = Info.append('text')
                              .attr("fill", "black")
                              .attr("text-anchor","left")
                              .attr("alignment-baseline","hanging")
                              .attr("font-size", 13)
                              .attr("x", 20)
                              .attr("y", 70)
              InfoText3.text(Info_detail_other1)

              let InfoText4 = Info.append('text')
                              .attr("fill", "black")
                              .attr("text-anchor","left")
                              .attr("alignment-baseline","hanging")
                              .attr("font-size", 13)
                              .attr("font-weight", 350)
                              .attr("x", 20)
                              .attr("y", 100)
              InfoText4.text(Info_detail_other2);

          }
          makeChoropleth();

      </script>
      <!-- Coding part to draw color legend for Plot 3 -->
      <script>

        function drawLegend(legend, legendColorScale) {

          const legendWidth = legend.attr("width");
          const legendHeight = legend.attr("height");
          const legendMinMax = d3.extent(legendColorScale.domain());
          const barHeight = 60;
          const stepSize = 4;
          const pixelScale = d3.scaleLinear().domain([0,legendWidth-40]).range([legendMinMax[0]-1,legendMinMax[1]+1]);
          const barScale = d3.scaleLinear().domain([legendMinMax[0]-1,legendMinMax[1]+1]).range([0,legendWidth-40]);
          const barAxis = d3.axisBottom(barScale);

          if (legendColorScale.hasOwnProperty('quantiles')) {
            barAxis.tickValues(legendColorScale.quantiles().concat( legendMinMax ));
          }
          legend.append("rect")
                .attr("x", 0)
                .attr("height", 300)
                .attr("y", 0)
                .attr("width", 900)
                .attr("fill", "white")

          legend.append("g")
            .attr("class", "colorbar axis")
            .attr("transform","translate("+(20)+","+(barHeight+5)+")")
            .call(barAxis);

          let bar = legend.append("g").attr("transform","translate("+(20)+","+(0)+")").attr("opacity", 0.8)
          for (let i=0; i<legendWidth-40; i=i+stepSize) {
            bar.append("rect")
              .attr("x", i)
              .attr("y", 0)
              .attr("width", stepSize)
              .attr("height",barHeight)
              .attr("fill", legendColorScale( pixelScale(i) ))


          }
          bar.append("line").attr("stroke","white").attr("stroke-width",3).attr("x1", barScale(legendMinMax[0])).attr("x2", barScale(legendMinMax[0])).attr("y1", 0).attr("y1", barHeight+4);
          bar.append("line").attr("stroke","white").attr("stroke-width",3).attr("x1", barScale(legendMinMax[1])).attr("x2", barScale(legendMinMax[1])).attr("y1", 0).attr("y1", barHeight+4);

        }

      </script>

    </p>
    </div>
</body>

</html>
