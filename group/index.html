<!DOCTYPE html>

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word cloud</title>
    <!--- D3 IMPORT HERE --->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-cloud/1.2.5/d3.layout.cloud.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/seedrandom/2.4.3/seedrandom.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <!--- D3 IMPORT HERE --->
    <style>

        h1 {
            font-weight: 500;
            font-size: 35pt;
            padding: 20;
            margin: 20;
            text-align: center;
        }

        h3 {
            font-weight: 350;
            font-size: 13pt;
            padding: 25;
            margin: 10;
            text-align: center;
        }

        h4 {
            font-weight: 500;
            font-size: 11pt;
            padding: 5;
            margin: 0;
            text-align: center;
        }

        .state {
            fill: lightgrey;
        }

        .graticule {
            fill: none;
            stroke: grey;
            stroke-width: 1px;
            opacity: 0.4;
        }

        .outline {
            fill: none;
            stroke: black;
            stroke-width: 1px;
        }

        /*
        styling for barchart
        */

        .gridlines .domain {
          display: none;
        }

        .gridlines line {
          stroke: lightgrey;
        }

        g.mouseover rect {
          stroke: #222;
          stroke-width: 1px;
        }
        g.mouseover text {
          font-family: Georgia, serif;
          font-size: 13px;
        }
        g.mouseover text:first-child {
          font-weight: bold;
          font-size: 15px;
        }

        label {
          font-family: Georgia, serif;
          font-size: 15px;
          font-weight: bold;
          font-style: italic;
        }


    </style>
</head>

<body>

    <h1> Analysis of Twitter Tweets </h1>

    <div id="p1" style="text-align: center;">
    <p id="p1">
        <h3> Graph 1: Most Mentioned Word Cloud by User Groups</h3>
        <div id="pulldown-bar" >
        	<label for="usergroup-select-1" id="usergroup-1">Usergroup: </label>
            <select id="sort-select" style="width:200px; margin-left: 5px; margin-top: 15px;" >
                <option value="full" selected>Show All Users</option>
                <option value="sport">Show Sport Analyst</option>
                <option value="nba">Show NBA Player</option>
                <option value="actor">Show Actor or Actress</option>
                <option value="entrepreneur">Show Entrepreneur</option>
                <option value="musician">Show Musician</option>
                <option value="cornell">Show Cornell Faculty</option>
                </select>
        </div>
        <svg id="word-cloud" height="500" width="900" style="margin:20px;" /> </svg>
        <ul id='list'>

        </ul>
        <script>
            // Math.seedrandom(42);

            let svg1 = d3.select("svg#word-cloud");
            let width1 = svg1.attr("width");
            let height1 = svg1.attr("height");

            let requestData = async function () {
                let word_freq;

                let full_freq = await d3.json("./datasets/word-freq-select-full.json");
                let actor_freq = await d3.json("./datasets/word-freq-select-actor.json")
                let cornell_freq = await d3.json("./datasets/word-freq-select-cornell.json")
                let entrepreneur_freq = await d3.json("./datasets/word-freq-select-entrepreneur.json")
                let musician_freq = await d3.json("./datasets/word-freq-select-musician.json")
                let nba_freq = await d3.json("./datasets/word-freq-select-nba.json")
                let sport_freq = await d3.json("./datasets/word-freq-select-sport.json")

                drawByData(full_freq)

                d3.select("#sort-select").on("change", function () {
                    svg1.selectAll("*").remove();

                    var option = d3.select(this).property("value")
                    console.log(option);

                    if (option === "actor") {
                        word_freq = actor_freq
                    }
                    else if (option === "cornell") {
                        word_freq = cornell_freq
                    }
                    else if (option === "entrepreneur") {
                        word_freq = entrepreneur_freq
                    }
                    else if (option === "musician") {
                        word_freq = musician_freq
                    }
                    else if (option === "nba") {
                        word_freq = nba_freq
                    }
                    else if (option === "sport") {
                        word_freq = sport_freq
                    }
                    else {
                        word_freq = full_freq
                    }

                    drawByData(word_freq)
                })

            }
            // call
            requestData();

            function drawByData(word_freq) {
                // let fill = d3.scaleOrdinal(d3.schemeCategory10);
                // let fill = d3.scaleOrdinal([`#383867`, `#584c77`, `#33431e`, `#a36629`, `#92462f`, `#b63e36`, `#b74a70`, `#946943`]);
                let fill = d3.scaleOrdinal(["#4e79a7","#f28e2c","#e15759","#76b7b2","#59a14f","#edc949","#af7aa1","#ff9da7","#9c755f","#bab0ab"]);

                let data1 = word_freq;
                const freqExtent = d3.extent(data1, d => d['value']);
                console.log(freqExtent);
                // const wordScale = d3.scaleLinear()
                //     .domain(freqExtent)
                //     .range([10, 120])
                const wordScale = d3.scaleLog()
                    .domain(freqExtent)
                    .range([20, 150])

                var layout = d3.layout.cloud()
                    .size([width1, height1])
                    .words(data1)
                    .font("Impact")
                    .fontSize(d => wordScale(d['value']))
                    .padding(3)
                    // .rotate(function () { return ~~(Math.random() * 2) * 90; })
                    .rotate(function () { return 0; })
                    .on("end", draw);

                layout.start();

                function draw(words) {
                  d3.select("svg#word-cloud")
                      .append("g")
                      .attr("id", "wordInCloud")
                      .attr("transform", "translate(" + layout.size()[0] / 2 + "," + layout.size()[1] / 2 + ")")
                      .selectAll("text")
                      .data(words)
                      .join("text")
                      .text((d) => d.text)
                      .style("font-size", (d) => d.size + "px")
                      .style("font-family", (d) => d.font)
                      .transition().duration(600)
                      .style("fill", (d, i) => fill(i))
                      .attr("text-anchor", "middle")
                      .attr("transform", (d) => "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")");
                }

            }
        </script>
    </p>
    </div>


    <div id="p2" style="text-align: center;">
    <p id="p2">
        <h3> Graph 2: Mentioned Frequency in Percentage by Groups & Users</h3>
        <div id = "dropdown">
          <label for="usergroup-select" id="usergroup">Usergroup: </label>
          <select id="usergroup-select" style="width:200px; margin-right: 50px; margin-left: 5px; margin-top: 15px;">
            <option value="AllUsers" selected>Show All Users</option>
            <option value="Sport Analyst">Show Sport Analyst</option>
            <option value="Actor or Actress">Show Actor or Actress</option>
            <option value="NBA Player">Show NBA Player</option>
            <option value="Musician">Show Musician</option>
            <option value="Entrepreneur">Show Entrepreneur</option>
            <option value="Cornell Faculty">Show Cornell Faculty</option>
          </select>

          <label for="keyword-select" id="word">Top Word: </label>
          <select id="keyword-select" style="width:200px; margin-left: 5px; margin-top: 15px;">
          </select>
        </div>



        <div id="barchart_svg">

          <svg id="bar-chart" height="600" width="800" style="margin-top: 1px; margin-bottom: 25px;">
          </svg>

        </div>

      <script id="p2">

          // Prepare & Plot the SVG
          const svg = d3.select("svg#bar-chart");
          const width = svg.attr("width");
          const height = svg.attr("height");
          const margin = {top: 50, right: 10, bottom: 50, left: 50};
          const chartWidth = width - margin.left - margin.right;
          const chartHeight = height - margin.top - margin.bottom;

          let annotations = svg.append("g").attr("id","annotations");
          let chartArea = svg.append("g").attr("id","points")
                          .attr("transform",`translate(${margin.left},${margin.top})`);

          // Create a small mouseover area
          const mouseover = svg.append("g").attr("class","mouseover")
                               .attr("transform",`translate(${margin.left+15},${margin.top+15})`);

         // Create a function to figure out the length of a string
          function stringLen(str) {
             const dummytext = mouseover.append("text").attr("class","legendtext").attr("visibility","hidden");
             dummytext.text(str)
             let len = dummytext.node().getComputedTextLength()
             dummytext.remove()
             return len;
          }

          const frame = mouseover.append("rect").attr("class","frame")
                                 // we style this in <head>
                                 .attr("x", 500).attr("y", 0)
                                 .attr("rx", 5).attr("ry", 5)  // rx and ry round corners
                                 .attr("height", 80);  // set width later
          const textbox = mouseover.append("g").attr("transform","translate(10,10)");
          const format = d3.format('.2s');

          // Create a function to updates the mouseover contents given a piece of data
          function updateMouseover(d) {

            textbox.html('');

            let twitter = `@${d['user']}`;
            let name = `${d['name']}`;
            let follower = `Follower: ${format(d['follower'])}`;

            let maxWidth = Math.max( stringLen(twitter), stringLen(name), stringLen(follower) )
            frame.attr("width", maxWidth+75);

            if ( d3.select("#usergroup-select").node().value === "AllUsers"){
              textbox.append("text").text(name)
                     .attr("x", 500).attr("y", 10);
              textbox.append("text").text(twitter)
                     .attr("x", 500).attr("y", 30);
              textbox.append("text").text(follower)
                     .attr("x", 500).attr("y", 50);

              let fill = colorScale(d['usergroup']);
              frame.attr('fill', fill)
                  .attr('opacity', 0.5);
            }
            else{
              textbox.append("text").text(name)
                     .attr("x", 5).attr("y", 10);
              textbox.append("text").text(twitter)
                     .attr("x", 5).attr("y", 30);
              textbox.append("text").text(follower)
                     .attr("x", 5).attr("y", 50);

              frame.attr('x', 5)
                  .attr('fill', 'white')
            }

          }

          // Create y-axis and y-gridelines
          // y-axis: represent the percentage of post containing a specific word
          // y-axis is going to change based on selected usergroup and word
          let leftAxis = d3.axisLeft().tickFormat(d3.format('.0%'));
          let leftAxisG = annotations.append("g")
                                    .attr("class", "y axis")
                                    .attr("transform",`translate(${margin.left-10},${margin.top})`);

          let leftGridlines = d3.axisLeft()
                                .tickSize(-chartWidth-10)
                                .tickFormat("");
          let leftGridlinesG = annotations.append("g")
                                    .attr("class", "y gridlines")
                                    .attr("transform",`translate(${margin.left-10},${margin.top})`);

          // Create colorScale for six usergroups
          const usergroup_categories = ['Sport Analyst', 'Actor or Actress', 'NBA Player', 'Musician', 'Entrepreneur', 'Cornell Faculty'];
          const colorpalate = ['#4e79a7', '#AF7AA1', '#E15759', '#FF9DA7', '#59A14F', '#F28E2C'];
          const colorScale = d3.scaleOrdinal()
                              .domain(usergroup_categories)
                              .range(colorpalate);

          // Create x-axis & x-gridlines
          // x-axis: represent different usergroups / different users
          // The x-axis is going to change because selected usergroup from dropdown menu changes
          let bottomAxis = d3.axisBottom();
          let bottomAxisG = annotations.append("g")
                                   .attr("class", "x axis")
                                   .attr("transform",`translate(${margin.left},${chartHeight+margin.top+10})`);

          // Create a function to update Bar Chart
          async function updateBarsAnimated( usergroup, word_chosen ) {

            // load in categorized_users.json data file
            const categorized_users = await d3.json("./barchart-datasets/user_under_categories.json", d3.autoType);
            console.log("Categorized Users: ", categorized_users);

            // create user account and name pairs
            let user_name_pair = new Array();
            categorized_users.forEach( d => {
              d.users.forEach( (u, i) => {
                user_name_pair[u] = d.names[i];
              })
            });

            // load in processed-date-top-words.json data file
            let data = await d3.json("./barchart-datasets/top-words_percent.json", d3.autoType);
            console.log("Data: ", data);

            // load in user-followers.csv file
            let followers = await d3.csv("./barchart-datasets/user-followers.csv", d3.autoType);
            console.log("Followers: ", followers);

            // remove all pre-existing bars
            let bars = d3.selectAll('rect.bar');
            bars.remove();

            //
            // Check whether usergroup === "AllUsers"
            //
            if( usergroup === "AllUsers") {
              const groups = d3.map(categorized_users, d => d.usergroup);
              const groupScale = d3.scaleBand()
                                  .domain(groups)
                                  .range([0, chartWidth])
                                  .padding(0.2);

              const userScale = d3.scaleBand()
                                  .domain([0, 1, 2, 3, 4])
                                  .range([0, groupScale.bandwidth()])
                                  .padding(0.15);

              bottomAxis.scale(groupScale);
              bottomAxisG.transition().call(bottomAxis);

              //
              // process data array to categorize user data
              //
              let processed_data = new Array();
              usergroup_categories.forEach( u => {
                // STEP 1: get all user accounts falling into the usergroup
                const group = d3.filter(categorized_users, d => (d.usergroup === u));
                let users = group[0].users;

                // StTEP 2: create processed array for later data join
                for ( const [key, value] of Object.entries(data) ){
                  let new_dict = {}
                  if (users.indexOf(key) >= 0) {
                    new_dict['user'] = key;
                    new_dict['name'] = user_name_pair[key];
                    new_dict['word_frequency'] = value;
                    new_dict['usergroup'] = u;
                    new_dict['index'] = users.indexOf(key);

                    // find the number of followers for the user
                    followers.forEach( (d,i) => {
                      if (d.Username === key) {
                        new_dict['follower'] = d.Follower_Count;
                      }
                    })

                    processed_data.push(new_dict);
                  }
                }

              })
              console.log('Processed Data: ', processed_data);


              // Create percenExtent for y-axis
              let word_frequency_count = [];
              processed_data.forEach( d => {
                word_frequency_count.push(d.word_frequency[word_chosen]);
              })

              let percentExtent = d3.extent(word_frequency_count);
              let percentScale = d3.scaleLinear().domain([0, percentExtent[1]])
                                    .range([chartHeight, 0]);
              // Draw y-axis & y-gridlines
              leftAxis.scale(percentScale);
              leftAxisG.transition().call(leftAxis);

              leftGridlines.scale(percentScale);
              leftGridlinesG.transition().call(leftGridlines);


              // use data join of processed_data to plot bar chart
              let bars = chartArea.selectAll('rect.bar').data(processed_data)
                                  .join( enter => enter.append('rect')
                                                       .attr('class','bar')
                                                       .attr('id', d => d.user)
                                                       .attr('fill', d => colorScale(d.usergroup))
                                                       .attr('x', d => groupScale(d.usergroup) + userScale(d.index))
                                                       .attr('y', d => percentScale(d.word_frequency[word_chosen]))
                                                       .attr('height', d => percentScale(0) - percentScale(d.word_frequency[word_chosen]))
                                                       .attr('width', userScale.bandwidth())
                                                       .attr('opacity', 0)
                                                       .call( enter => enter.transition().attr('opacity',0.9) ),
                                        update => update.call( update => update.transition()
                                                                                .attr('fill', d => colorScale(d.usergroup))
                                                                                .attr('x', d => groupScale(d.usergroup) + userScale(d.index))
                                                                                .attr('y', d => percentScale(d.word_frequency[word_chosen]))
                                                                                .attr('height', d => percentScale(0) - percentScale(d.word_frequency[word_chosen]))
                                                                                .attr('width', userScale.bandwidth()) ),
                                        exit => exit.call( exit => exit.transition().attr('opacity',0).remove() )

                                      );

              // Add some mouseover events
              bars.on('mouseover', function(d) {
                mouseover.attr("visibility","");
                updateMouseover( d3.select(this).datum() )
              })

              bars.on('mouseout', function(){
                mouseover.attr("visibility","hidden");
              })

            }

            //
            // Show Bar Chart for a Single User Group
            //
            else {
              // get the data for specific user group
              const group = d3.filter(categorized_users, d => (d.usergroup === usergroup));
              // get all users' Twitter accounts
              let users = group[0].users;
              // get all users' real names
              let names = group[0].names;

              const userScale = d3.scaleBand()
                                  .domain(names)
                                  .range([0, chartWidth])
                                  .padding(0.25);

              bottomAxis.scale(userScale);
              bottomAxisG.transition().call(bottomAxis);

              let users_data = new Array();

              // get the corresponding user data from data array
              for ( const [key, value] of Object.entries(data) ){
                let new_dict = {}
                if (users.indexOf(key) >= 0) {
                  new_dict['user'] = key;
                  new_dict['name'] = user_name_pair[key];
                  new_dict['word_frequency'] = value;
                  new_dict['index'] = users.indexOf(key);

                  // find the number of followers for the user
                  followers.forEach( (d,i) => {
                    if (d.Username === key) {
                      new_dict['follower'] = d.Follower_Count;
                    }
                  })

                  users_data.push(new_dict);
                }
              }
              console.log("User Data: ", users_data);

              // Create percenExtent for y-axis
              let word_frequency_count = [];
              users_data.forEach( d => {
                word_frequency_count.push(d.word_frequency[word_chosen]);
              })

              let percentExtent = d3.extent(word_frequency_count);
              let percentScale = d3.scaleLinear().domain([0, percentExtent[1]])
                                    .range([chartHeight, 0]);
              // Draw y-axis & y-gridlines
              leftAxis.scale(percentScale);
              leftAxisG.transition().call(leftAxis);

              leftGridlines.scale(percentScale);
              leftGridlinesG.transition().call(leftGridlines);

              // Use data join to append bars
              let bars = chartArea.selectAll('rect.bar').data(users_data)
                                  .join(
                                    enter => enter.append('rect')
                                                         .attr('class','bar')
                                                         .attr('id', d => d.user)
                                                         .attr('fill', colorScale(usergroup))
                                                         .attr('x', d => userScale(user_name_pair[d.user]))
                                                         .attr('y', d => percentScale(d.word_frequency[word_chosen]))
                                                         .attr('height', d => percentScale(0) - percentScale(d.word_frequency[word_chosen]))
                                                         .attr('width', userScale.bandwidth())
                                                         .attr('opacity', 0)
                                                         .call( enter => enter.transition().attr('opacity',0.9) ),
                                    update => update.call( update => update.transition()
                                                                            .attr('fill', colorScale(usergroup))
                                                                            .attr('x', d => userScale(user_name_pair[d.user]))
                                                                            .attr('y', d => percentScale(d.word_frequency[word_chosen]))
                                                                            .attr('height', d => percentScale(0) - percentScale(d.word_frequency[word_chosen]))
                                                                            .attr('width', userScale.bandwidth()) ),
                                    exit => exit.call( exit => exit.transition().attr('opacity',0).remove() )
                                  );

              // add some mouseover events
              // Add some mouseover events
              bars.on('mouseover', function(d) {
                mouseover.attr("visibility","");
                updateMouseover( d3.select(this).datum() )
              })

              bars.on('mouseout', function(){
                mouseover.attr("visibility","hidden");
              })

            }

          }

          // Default drop-down menus for all user groups
          var usergroup_selected = d3.select("#usergroup-select").node().value;
          // Build the corresponding keyword selectors
          buildKeywordSelet( usergroup_selected );
          // initialize the bar chart
          updateBarsAnimated( "AllUsers", "game" );

          d3.select("#keyword-select").on("change", function(){
            keyword_selected = d3.select(this).property("value");
            // console.log("User Group Chosen: ", usergroup_selected);
            // console.log("Top Word Chosen: ", keyword_selected);
            updateBarsAnimated( usergroup_selected, keyword_selected );

          })

          // Update the drop-down menus
          // Get "usergroup-select" value property
          // then build "keyword-select" options
          d3.select("#usergroup-select").on("change", function(){
            // get the "usergroup-select" option value
            usergroup_selected = d3.select(this).property("value");
            console.log("Usergroup: ", usergroup_selected);
            // call buildKeywordSelet function to build "keyword-select" options
            buildKeywordSelet( usergroup_selected );
            // get the "keyword-select" option value
            d3.select("#keyword-select").on("change", function(){
              keyword_selected = d3.select(this).property("value");
              // console.log("User Group Chosen: ", usergroup_selected);
              // console.log("Top Word Chosen: ", keyword_selected);
              updateBarsAnimated( usergroup_selected, keyword_selected );

            })

            let initial_word = {"AllUsers": "game", "Sport Analyst": "lebron", "Actor or Actress": "love",
            "NBA Player": "lol", "Musician": "steveaoki", "Entrepreneur": "uber", "Cornell Faculty": "data"};

            updateBarsAnimated( usergroup_selected, initial_word[usergroup_selected] );
          });

          //
          // Create a function to build "keyword-select" options
          //
          async function buildKeywordSelet( usergroup ) {

            // Call requestTopWords( usergroup ) to get option list
            let option_list = await requestTopWords( usergroup );
            // Append the option
            let keyword_select = d3.select("select#keyword-select");
            let word_options = d3.selectAll("option#words");

            // Remove all pre-existing options
            word_options.remove();

            // Create new options for the "keyword-select"
            option_list.forEach( (d,i) => {
                keyword_select.append("option")
                            .attr("id", "words")
                            .attr("value", d.text)
                            .text(d.format)
            })

          } // END OF buildKeywordSelet FUNCTION

          //
          // Create a function to load the top words
          //
          async function requestTopWords( usergroup ) {

            let top_words;

            // Get the top 10 words shared by 6 user groups
            if (usergroup === "AllUsers") {
              // load top-words-AllUsers dataset
              top_words = await d3.json("./barchart-datasets/top-words-AllUsers.json", d3.autoType);
            }
            // Get the top 5 words shared by an individual user group
            else {
              // load the corresponding datasets
              top_words = await d3.json("./barchart-datasets/top-words-"+usergroup+".json", d3.autoType);
            }

            return top_words;

          }// END OF requestWord_All_Groups FUNCTION

        </script>

    </p>
    </div>


    <div id="p3" style="text-align: center;">
    <p id="p3">
        <h3> Graph 3: States Mentioned by Sports Analysts</h3>
        <div id="sport-analyst-dropdown">
            <label for="sport-analyst" id="users">
            	Choose a Sports Analyst:
            </label>
            <select id="sport-analysts" style="width:200px; margin-left: 5px; margin-top: 15px">
              <option value="total">All Sports Analysts</option>
              <option value="maxkellerman">Max Kellerman</option>
              <option value="PatMcAfeeShow">Pat McAfee</option>
              <option value="RealSkipBayless">Skip Bayless</option>
              <option value="ShannonSharpe">Shannon Sharpe</option>
              <option value="stephenasmith">Steven A. Smith</option>
            </select>
        </div>

    <svg id="userInfo" height="120" width="700" style="background: #fff; margin-top:2px"></svg>
    <svg id="choropleth" height="600" width="900" style="background: #F1F9FF; margin-top:2px"></svg>
    <svg id="colorLegend" height="100" width="700" style="background: #fff; margin-top:2px"></svg>



<script>
    const svg3 = d3.select('#choropleth');

    // Get the attributes of the svg
    const svgWidth3 = svg3.attr('width');
    const svgHeight3 = svg3.attr('height');

    // Create choropleth map attributes
    const margin3 = { left: 10, right: 10, top: 10, bottom: 10 };
    const plotWidth3 = svgWidth3 - margin3.left - margin3.right;
    const plotHeight3 = svgHeight3 - margin3.top - margin3.bottom;

    const plot = svg3.append('g').attr('transform', `translate(${margin3.left}, ${margin3.right})`);

    let tweetStateData;
    let freq = {};

    // Create the popup
    let popupWidth = 120;
    let popupHeight = 50;

    let momesh = plot.append('path')
                        .attr('class', 'mouseover outline')
                        .attr('d', '')

    let popup = plot.append('g')
                    .attr('class', 'popup')
                    .attr('visiblity', 'hidden')

    popup.append('rect')
            .attr('fill', 'black')
            .attr('opacity', 0.8)
            .attr('x', -popupWidth / 2)
            .attr('y', 0)
            .attr('width', popupWidth)
            .attr('height', popupHeight)
    popup.style('visibility','hidden');

    let stateText = popup.append('text')
                            .attr("fill", "white")
                            .attr("text-anchor","middle")
                            .attr("alignment-baseline","hanging")
                            .attr("font-size", 15)
                            .attr("x", 0)
                            .attr("y", 10);

    let freqText = popup.append('text')
                        .attr("fill", "white")
                        .attr("text-anchor","middle")
                        .attr("alignment-baseline","hanging")
                        .attr("font-size", 15)
                        .attr("x", 0)
                        .attr("y", 30);


    let path, data;

    const makeChoropleth = async function() {

        // Load twitter data for choropleth map
        tweetStateData = await d3.json('./datasets/twitterStateMentions.json', d3.autotype);
        //console.log('DATA');
        //console.log(tweetStateData);

        // Modeled after topojson lecture code by Prof Rz.
        data = await d3.json('./datasets/us-smaller.json');

        let states = topojson.feature(data, data.objects.states);
        let statesMesh = topojson.mesh(data, data.objects.states);
        let projection2d = d3.geoAlbersUsa().fitSize([plotWidth3, plotHeight3], states);
        path = d3.geoPath().projection(projection2d);
        let graticule = d3.geoGraticule10();

        plot.append('path')
            .attr('class', 'graticule')
            .attr('d', path(graticule))

        plot.selectAll('path.state')
            .data(states.features)
            .join('path')
            .attr('class', 'state')
            .attr('d', path)

        plot.append('path')
            .datum(statesMesh)
            .attr('class', 'outline')
            .attr('d', path)

        let dropdown = d3.select('select#sport-analysts')
            .on('change', updateChoropleth)

        let emptyData = await d3.csv('./datasets/empty-states.csv', d3.autotype);
        stateMap = {}
        emptyData.forEach( obj => {
            stateMap[obj.state_code] = obj.state_name;
        })
        //(emptyData);
        //console.log(stateMap)

        d3.selectAll('.state').on('mouseenter', function() {
            return mouseEnterState(this, stateMap)
        });
        d3.selectAll('.state').on('mouseout', mouseExitState);

        updateChoropleth(); // update once with the cumulative data
    }

    function mouseEnterState(obj, stateMap) {
        //console.log('ENTER');

        popup.style('visibility', 'visible');
        popup.raise();
        let currentState = d3.select(obj);
        let currentStateId = currentState.datum().id;

        stateText.text(stateMap[currentStateId]);
        freqText.text(d3.format('.2f')(freq[currentStateId]*100) + '%')
        //console.log(freq);
        let currentStateBounds = path.bounds(currentState.datum());

        // Ceter it above the current state
        let xPos = (currentStateBounds[0][0] + currentStateBounds[1][0]) / 2;
        let yPos = currentStateBounds[0][1] - popupHeight + 10;

        popup.attr('transform', `translate(${xPos}, ${yPos})`);
        //console.log(xPos, yPos);

        let mo = topojson.mesh(data, data.objects.states, function(a, b) { return a.id === currentStateId || b.id === currentStateId; });
        momesh.datum(mo).attr("d", path);

    }

    function mouseExitState() {
        //('EXIT');

        popup.style('visibility','hidden');
        momesh.attr("d", "");

   }

    const updateChoropleth = async function() {
        console.log("UPDATING");
        console.log(tweetStateData);

        let select = d3.select('select#sport-analysts');
        let username = select.node().value;

        let total = Number(tweetStateData['Num_Tweets'][username]);
        let emptyStateData = await d3.csv('./datasets/empty-states.csv', d3.autotype);
        //console.log(emptyStateData);

        // Create dictionaries to store the plot data - modeled after Prof Rz's lecture
        counts = {};
        names = {};
        freq = {};

        let count;
        // Update emptyStateData based on the selected user
        emptyStateData.forEach( (obj) => {
            count = tweetStateData[obj.state_name][username];
            obj.total = count;
            counts[obj.state_code] = count;
            names[obj.state_code] = obj.state_name;
            freq[obj.state_code] = count * 100 / total;
        })

        //console.log("NEW DATA");
        //console.log(emptyStateData);

        console.log('COUNTS');
        console.log(counts);

        // Styling
        let colorScale = d3.scaleQuantile()
                            .domain(Object.values(counts))
                            .range(["#B3D0ED","#5A8BBC","#1B4875","#082F56"]);

        // Color the choropleth map
        plot.selectAll('path.state')
            .style('fill', d => colorScale(counts[d.id]))
            .attr("opacity", 0.8)

        // Draw legend
        const map_legend = d3.select("svg#colorLegend")

        drawLegend(d3.select("#colorLegend"), colorScale);

        const Info = d3.select('svg#userInfo');
        Info.append("rect")
            .attr("x", 0)
            .attr("height", 300)
            .attr("y", 0)
            .attr("width", 900)
            .attr("fill", "white")


       let Info_detail_max5, Info_detail_other1, Info_detail_other2, Info_detail_other3;
        if (username === "total") {
            Info_detail_max5 = "Top 5 States: Maine / Indiana / Washington / Texas / Ohio"
            Info_detail_other1 = " "
            Info_detail_other2 = " "
        }
        else if (username === "RealSkipBayless") {
            Info_detail_max5 = "Top 5 States: Texas / Oklahoma / Washington / Ohio / Arizona"
            Info_detail_other1 = "1)　Born in Oklahoma City, Oklahoma"
            Info_detail_other2 = "2)　Fan of the Dallas Cowboys (Texas) NFL team and Oklahoma Sooners College Football Team"
        }
        else if (username === "ShannonSharpe") {
            Info_detail_max5 = "Top 5 States: Maine / Indiana / Washington / Texas / Ohio"
            Info_detail_other1 = "1)　Attended Savannah State University (Georgia)"
            Info_detail_other2 = "2)　Played in the NFL for the Denver Broncos (Colorado) and Baltimore Ravens (Maryland)"
        }
        else if (username === "PatMcAfeeShow") {
            Info_detail_max5 = "Top 5 States: Indiana / Ohio / Washington / Virginia / Texas"
            Info_detail_other1 = "1)　Born in Pennsylvania"
            Info_detail_other2 = "2)　Played in the NFL for the Indianapolis Colts (Indiana)"
        }
        else if (username === "maxkellerman") {
            Info_detail_max5 = "Top 5 States: Kentucky / New York / Alabama / Washington / Ohio"
            Info_detail_other1 = "1)　Hosts ESPN shows in New York"
            Info_detail_other2 = "2)　Avid boxing fan"
        }
        else if (username === "stephenasmith") {
            Info_detail_max5 = "Top 5 States: New York / Alabama / Michigan / Kentucky / Ohio"
            Info_detail_other1 = "1)　Hosts ESPN shows in New York"
            Info_detail_other2 = "2)　Infamous Dallas Cowboys 'hater' "
        }

        let InfoText = Info.append('text')
                        .attr("fill", "black")
                        .attr("text-anchor","left")
                        .attr("alignment-baseline","hanging")
                        .attr("font-size", 14)
                        .attr("font-weight", 800)
                        .attr("x", 20)
                        .attr("y", 10);

        if (username === "total") {
          InfoText.text("All Sports Analysts");
        }

        else {
          InfoText.attr("font-style", "italic");
          InfoText.text("@"+username);
        }

        let InfoText_max = Info.append('text')
                        .attr("fill", "black")
                        .attr("text-anchor","left")
                        .attr("alignment-baseline","hanging")
                        .attr("font-size", 13)
                        .attr("font-weight", 350)
                        .attr("x", 20)
                        .attr("y", 40)
        InfoText_max.text(Info_detail_max5)

        let InfoText3 = Info.append('text')
                        .attr("fill", "black")
                        .attr("text-anchor","left")
                        .attr("alignment-baseline","hanging")
                        .attr("font-size", 13)
                        .attr("x", 20)
                        .attr("y", 70)
        InfoText3.text(Info_detail_other1)

        let InfoText4 = Info.append('text')
                        .attr("fill", "black")
                        .attr("text-anchor","left")
                        .attr("alignment-baseline","hanging")
                        .attr("font-size", 13)
                        .attr("font-weight", 350)
                        .attr("x", 20)
                        .attr("y", 100)
        InfoText4.text(Info_detail_other2);

    }
    makeChoropleth();



</script>

<script>

    function drawLegend(legend, legendColorScale) {

      const legendWidth = legend.attr("width");
      const legendHeight = legend.attr("height");
      const legendMinMax = d3.extent(legendColorScale.domain());
      const barHeight = 60;
      const stepSize = 4;
      const pixelScale = d3.scaleLinear().domain([0,legendWidth-40]).range([legendMinMax[0]-1,legendMinMax[1]+1]);
      const barScale = d3.scaleLinear().domain([legendMinMax[0]-1,legendMinMax[1]+1]).range([0,legendWidth-40]);
      const barAxis = d3.axisBottom(barScale);

      if (legendColorScale.hasOwnProperty('quantiles')) {
        barAxis.tickValues(legendColorScale.quantiles().concat( legendMinMax ));
      }
      legend.append("rect")
            .attr("x", 0)
            .attr("height", 300)
            .attr("y", 0)
            .attr("width", 900)
            .attr("fill", "white")

      legend.append("g")
        .attr("class", "colorbar axis")
        .attr("transform","translate("+(20)+","+(barHeight+5)+")")
        .call(barAxis);

      let bar = legend.append("g").attr("transform","translate("+(20)+","+(0)+")").attr("opacity", 0.8)
      for (let i=0; i<legendWidth-40; i=i+stepSize) {
        bar.append("rect")
          .attr("x", i)
          .attr("y", 0)
          .attr("width", stepSize)
          .attr("height",barHeight)
          .attr("fill", legendColorScale( pixelScale(i) ))


      }
      bar.append("line").attr("stroke","white").attr("stroke-width",3).attr("x1", barScale(legendMinMax[0])).attr("x2", barScale(legendMinMax[0])).attr("y1", 0).attr("y1", barHeight+4);
      bar.append("line").attr("stroke","white").attr("stroke-width",3).attr("x1", barScale(legendMinMax[1])).attr("x2", barScale(legendMinMax[1])).attr("y1", 0).attr("y1", barHeight+4);



    }
</script>
    </p>
    </div>
</body>

</html>
